
/*
// for (int i = 0; i < minimapWidth; i++) {
//         for(int j = 0; j < minimapHeight; j++) {
//
//
//             int r = 0, g = 0, b = 0;
//             for (int k = 0; k < pixelWidth; k++) {
//                 for (int l = 0; l < pixelHeight; l++) {
//
//                     int index = (int)(i * pixelWidth + k) + (int)(j * pixelHeight + l) * mapWidth;
//                     r += colormap[index].r;
//                     g += colormap[index].g;
//                     b += colormap[index].b;
//                 }
//             }
//
//             r /= ceil(pixelWidth) * ceil(pixelHeight);
//             g /= ceil(pixelWidth) * ceil(pixelHeight);
//             b /= ceil(pixelWidth) * ceil(pixelHeight);
//
//             if(i == 0 && j == 0) {
//             }
//
//             float iscreen = i - minimapWidth / 2;
//             float jscreen = j - minimapHeight / 2;
//
//
//             iscreen = (1 * iscreen) + (-tan(playerAngle / 2) * jscreen);
//             jscreen = (0 * iscreen) + (                    1 * jscreen);
//
//             iscreen = (               1 * iscreen) + (0 * jscreen);
//             jscreen = (sin(playerAngle) * iscreen) + (1 * jscreen);
//
//             iscreen = (1 * iscreen) + (-tan(playerAngle / 2) * jscreen);
//             jscreen = (0 * iscreen) + (                    1 * jscreen);
//
//
//             mat2x2 mat1 = mat2x2(1);
//             mat1[1] = -tan(playerAngle/2);
//             mat2x2 mat2 = mat2x2(1);
//             mat2[2] = sin(playerAngle);
//             vec2 vec {iscreen, jscreen};
//
//             vec2 nVec = mat1 * mat2 * mat1 * vec;
//
//             display.SetPixel(roundf(nVec.x) + 128, roundf(nVec.y) + 128,
//             { (uint8_t)(r),
//               (uint8_t)(g),
//               (uint8_t)(b), 0xff });
//         }
//     }
     
     mat3x3 matFinal(1.f), matA(1.f), matB(1.f), matC(1.f), matFinalInv(1.f);
     
     matA.translate(-(mapWidth * 0.2)/2.f, -(mapHeight * 0.2)/2.f);
     matB.scale(0.2, 0.2);
     matC.rotate(playerAngle);
     
     matFinal = matC * matA * matB;
     matA.translate(+(mapWidth * 0.2)/2.f, +(mapHeight * 0.2)/2.f);
     matFinal = matA * matFinal;
     
     matFinalInv = matFinal.inverse();
     
     vec3 p;
     float sx, sy;
     float ex, ey;
     
     p = matFinal * (vec3){0, 0, 1};
     sx = p.x;
     sy = p.y;
     ex = p.x;
     ey = p.y;
     p = matFinal * (vec3){(float)mapWidth, (float)mapHeight, 1};
     sx = std::min(sx, p.x);
     sy = std::min(sy, p.y);
     ex = std::max(ex, p.x);
     ey = std::max(ey, p.y);
     p = matFinal * (vec3){(float)0, (float)mapHeight, 1};
     sx = std::min(sx, p.x);
     sy = std::min(sy, p.y);
     ex = std::max(ex, p.x);
     ey = std::max(ey, p.y);
     p = matFinal * (vec3){(float)mapWidth, (float)0, 1};
     sx = std::min(sx, p.x);
     sy = std::min(sy, p.y);
     ex = std::max(ex, p.x);
     ey = std::max(ey, p.y);

     int playerX = player.position.x;
     int playerY = player.position.y;

     while (playerX < 0)
         playerX += mapWidth-1;
     while (playerY < 0)
         playerY += mapHeight-1;
     while (playerX >= mapWidth-1)
         playerX -= mapWidth-1;
     while (playerY >= mapHeight-1)
         playerX -= mapHeight-1;

     for(int x = 0; x < mapWidth * 0.2; x++) {
         for(int y = 0; y < mapHeight * 0.2; y++) {
             p = matFinalInv * (vec3){(float)x, (float)y, 1};
             
             if(x < 0 || y < 0 || x > display.GetWidth() || y > display.GetHeight()) {
 //                display.SetPixel(x, y, (RGB){255, 255, 255});
                 continue;
             }
             if(p.x < 0)
                 p.x = p.x + mapWidth;
             if(p.y < 0)
                 p.y = p.y + mapHeight;
             if(p.x > mapWidth)
                 p.x = p.x - mapWidth;
             if(p.y > mapHeight)
                 p.y = p.y - mapHeight;

             
             int mx = ((int)p.x + playerX) % mapWidth;
             int my = ((int)p.y + playerY) % mapHeight;
             int index = mx + my * mapWidth;
             RGB pixel = colormap[index];
             display.SetPixel(x, y, pixel);
         }
     }
*/
